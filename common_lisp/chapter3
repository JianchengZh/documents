笔记

所有不是cons对象的东西,就是一个原子(atom),判断atom可以这样定义: (defun out-atom (x) (not (consp x)))

nil既是一个原子,也是一个列表.

(eql (cons 'a nil) (cons 'a nil)) 结果为NIL.因为每次调用cons,lisp都会分配一块新的内存给两个指针.所以,即使相同参数,调用cons两次,得到的也是不同的对象.

而想要比较内容相等,可以使用equal函数. (equal (cons 'a nil) (cons 'a nil))  返回T

关于lisp中的指针.其实可以类比地这么看lisp中的变量.lisp中变量其实就是指针.比如,把一个list结构赋值给某个变量,就是把该结构的指针赋值给某个变量.所以对于beginner而言,就可以认为lisp中的变量就是指针.当然,出于优化考虑,比如存储比指针内存占用小的整形数值,可能会直接赋值给变量,而不是指针.这些行为都是lisp在后台处理了的.
从这点出发,lisp中的一个基本要点是,它允许程序员把任何东西放在任何地方.


nth和nthcdr函数都是从0开始索引的(zero-indexed),即元素从0开始编号,而不是从1开始.应该说在common lisp里,跟在C里一样,都是从0开始编号.

last函数是返回列表的最后一个Cons对象,即(last '(a b c)) 返回(C). 而如果需要获得最后一个元素,需要(car (last '(a b c)))

映射函数(Mapping Functions) 指对一个列表里的元素做函数调用.最常使用的是mapcar,接受一个函数以及一个或多个列表,并返回把函数应用至每个列表的元素的结果,直到有的列表没有元素为止.
(mapcar #'(lambda (x) (+ x 10)) '(1 2 3)) 输出结果为(11 12 13)
(mapcar #'list '(a b c) '(1 2 3 4)) 输出结果为((A 1) (B 2) (C 3))
(maplist #'(lambda (x) x) '(a b c)) 输出结果为((A B C) (B C) (C))

树结构. Cons对象可以看成是二叉树,car代表左子树而cdr代表右子树.树相关的函数有如下. 一般操作树的方法为,car和cdr同时递归,这种函数被称为双重递归.
copy-tree 接受一个树并返回一个副本.
subst     替换树之中的元素

关键字参数: 个人理解,关键字参数就类似C语言里面的函数指针.用我们自己定义的函数替换掉原先调用里的某些函数,然后执行查看结果.
(member 'a '((a b) (c d)) :key #'car :test #'equal) :key关键字的函数会对每个参数求值, :test 参数是比较函数,默认是eql. 这里,我们把:key关键字对应的函数改成调用我们指定的car; :test关键字对应的函数改成我们指定的equal.该函数的功能就是,询问是否有一个元素的car等于(equal) 'a.

集合论中的并集(union),交集(intersection)以及补集(complement)的实现,是由函数union,intersection以及set-difference.这些函数期望两个(正好2个)列表(一样接受member函数同样的关键字参数).
(union '(a b c) '(c b s)) 执行结果是(A C B S)
(intersection '(a b c) '(b b c)) 执行结果为 (C B)
(set-difference '(a b c d e) '(b e)) 执行结果为 (D C A)

总结:目前虽然了解到的基本数据结构只有list,但基于这简单的数据结构,却能实现堆栈,树等复杂的数据结构.难怪有人会误解,lisp只有list一种数据结构呢.
垃圾回收是有代价的,所以写出在具有垃圾回收机制的下的高效代码也是具有挑战性的.首先,不能写出过度显式地创建cons对象的程序.避免这种情况的一种做法是,使用破坏性的函数(即,修改和重用函数参数)实现.这,应该属于优化阶段该做的事情!!
1. 一个cons是一个含两部分的数据结构.列表用链结在一起的cons组成.
2. 判断式equal比eql来的不严谨.基本上,如果传入参数印出来的值一样,返回为真.
3. 所有lisp对象表现得像指针.你永远不需要显示操作指针.
4. 你可以使用copy-list复制列表,并使用append来连接它们的元素.
5. 游程编码是一个餐厅中使用的简单压缩算法.
6. Common lisp 有由car与cdr定义的多种存取函数.
7. 映射函数应用函数至逐项的元素,或逐项的列表尾端.
8. 嵌套列表的操作有时被考虑为树的操作.
9. 要判断一个递归函数是否正确,你只需要考虑是否包含了所有情况.
10. 列表可以用集合表示.数个内置函数把列表当作集合.
11. 关键字参数是选择性的,并不是由位置所识别,是用符号前面的特殊标签来识别.集体用法参考前面的理解.
12. 列表是序列的子类型.Common Lisp有大量的序列函数.
13. 一个不是正规列表的Cons称之为点状列表.
14. 用Cons对象作为元素的列表,可以拿来表示对应关系.这样的列表称之为关联列表.
15. 自动内存管理拯救你处理内存配置的烦恼,但制造过多的垃圾会使程序变慢.

Exercises:

