* tcmalloc2.1 浅析

** 简介
   tcmalloc(thread cached malloc) 是由google为并发程序而开发的内存分配管理器.tcmalloc致力于
   减少多线程内存请求时对锁的竞争, 在对小内存的申请时, 可以在无需锁的
   情况下高效获取内存;而在获取大内存时,使用高校的spinlocks.正因为
   tcmalloc是在线程局部空间(TLS)预先存储部分空闲内存用于分配, 在程序刚
   启动时,其所占用的内存会比dlmalloc或其他的内存管理器更大,但其增长速
   幅度比其他管理器小,所以,在后期,实际占用内存空间会相接近.

** 原理简析

*** overview

    [[https://raw.githubusercontent.com/pengzhangdev/documents/master/tcmalloc/overview.gif]]


    tcmalloc为每一个线程分配一个线程本地缓存(Thread Cache)．所有小对象
    (<256K)都会优先从Thread Cache分配．而当Thread Cache没有足够空闲内
    存时，就会从Central Heap申请内存. 而当Thread Cache内存富裕时,会将
    内存返回给Central Heap. Central Heap 是以进程为单位存在,Thread
    Cache是以线程为单位存在.
    对于大内存(>256K), 直接从Page Heap 按页对齐(4K)申请.
    通常情况下, 一连串的页面(4k)可以多个小内存序列,每个序列元素等大小.
    TC, CC, PH 的关系是, TC 向CC申请内存并GC给CC. CC 向PH 申请内存并GC
    给PH.
    在TC中的数据单位时字节, 按大小为单位分类,每个类中时链表.
    在PH中的数据单位时Page(4K), 按PageNum分类,每个分类内部用链表管理,
    第PageNum类的链表结点为PageNum个Page.
    在CC中存在最多的数据结构,它连接着TC和PH. 其存放了来自CC的slot结构,
    和来自PH的PH的span结构.
    数据的移动. 所有的数据从TC<->CC<->PH 都是批量(batch)移动.从TC申请
    或释放的内存都会优先从CC的slots数组处理. slots存放的就是最近从TC释
    放的内存,用于快速的TC内存申请.如果slots条件不满足,就会操作CC中的
    spans对象.所有移动的数据的大小和TC中的最大大小都是在动态调整的.

*** 小对象内存分配
    [[https://raw.githubusercontent.com/pengzhangdev/documents/master/tcmalloc/threadheap.gif]]
    上图为小内存管理时的sizemap分类的示意图.小内存的管理都处于
    ThreadCache中.所有对于256k以下的内存申请都是从TC中获取.
    个人把小内存分配,理解为3级内存请求.进程向TC请求内存, TC向CC请求内
    存,CC向PH请求内存.
**** 进程向TC请求和释放内存内存
     申请内存小于256K, 则优先尝试从TC中获取.
     释放的内存的pageID属于TC时,并且TC的Heap存在,则释放到TC.

     这里, 进程也有可能直接向CC或PH释放内存的.
     如果pageID属于TC, 而TC中Heap为NULL(一般几乎不可能),则该内存直接释
     放给CC.
     如果pageID不属于TC,则在PH中查找,并释放给PH.(大内存的情况)

***** 分类管理
      如上图, 在TC中对内存进行了分类管理,每一个请求的内存大小都会向上
      取整到对应分类,然后直接从对应的链表中取出一项.

**** TC向CC请求和释放内存

***** CC的内存管理.
      在CC中同样维护了与TC中对应的分类箱子.每个类别中是一个
      CentralFreeList类. 该类中维护了一个slots双向链表, 用于快速分配内
      存给CC并接收释放的内存.同样,该类中也维护了两个span双向链表,
      empty(不包含空闲块)和nonempty(包含空闲块).
      Span是个什么东西呢?它是PH内存管理的一个粒度,其表示的内存大小为
      page(4K)的倍数.同时,它包含了更小的粒度单位objects. 所以,也可以认
      为它是CC和PH之间移动的内存单元.
      所以,Span和slots的关系是,spans可以拆分成slots

      这里,我们认为span属于PH的,所以,跟span的相关操作我们在PH讲解.

#+BEGIN_SRC cpp
// Information kept for a span (a contiguous run of pages).
struct Span {
  PageID        start;          // Starting page number
  Length        length;         // Number of pages in span
  Span*         next;           // Used when in link list
  Span*         prev;           // Used when in link list
  void*         objects;        // Linked list of free objects
  unsigned int  refcount : 16;  // Number of non-free objects // 当refcount为0, 则释放给PageHeap.
  unsigned int  sizeclass : 8;  // Size-class for small objects (or 0)  // 这个是TC的 SizeClass 分类.因为每个分类对应一个CentralFreeList,每个List对应1个slots和2个spans. 所以,spans中的objects都统一属于某个SizeClass, 这里需要维护这个数据对object的.
  unsigned int  location : 2;   // Is the span on a freelist, and if so, which?  // 在empty/nonempty list?
  unsigned int  sample : 1;     // Sampled object?

#undef SPAN_HISTORY
#ifdef SPAN_HISTORY
  // For debugging, we can keep a log events per span
  int nexthistory;
  char history[64];
  int value[64];
#endif

  // What freelist the span is on: IN_USE if on none, or normal or returned
  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };
};
#+END_SRC

***** TC向CC请求内存
      TC只有在无法满足应用请求的情况下才会向CC申请内存. TC和CC之间的内
      存是批量移动的. 在某个类别无法满足请求的大小时,该类别会向CC申请内
      存.
#+BEGIN_SRC cpp
inline void* ThreadCache::Allocate(size_t size, size_t cl) {
  // size 已经被向上对齐, cl为分类的箱号
  ASSERT(size <= kMaxSize);
  // kMaxSzie == 256 * 1024
  ASSERT(size == Static::sizemap()->ByteSizeForClass(cl));
  // sizemap() 为分类的数组.每个成员为链表.
  // ByteSizeForClass是取出对应箱号内的理论内存大小.

  // 以上assert 检查,理应在调用该函数之前保证.

  FreeList* list = &list_[cl];
  if (list->empty()) {
    return FetchFromCentralCache(cl, size);
  }
  size_ -= size;
  return list->Pop();
}
#+END_SRC

      我们重点描述下,TC向CC申请内存的过程.首先,我们需要知道,CC也按照TC
      的内存分类方式,存在各个分类的箱子. 所以,实际上是向CC中的对应分类
      获取一连串的空闲内存.
      首先,我们得确定,移动的内存数量,也就是对应分类的内存块个数.默认情
      况下, 有一个规则确定每个分类对应的该移动的内存数量.以64K为基准,除
      以对应分类的内存大小,算出来的为移动的内存数量.但是,对于一些极小内
      存,这个值将很大,所以,我们限制最大为64个,同理,对于极大内存,这个值
      <=1,会导致这个分类的内存请求每次都向CC请求,所以,我们这只最小为2,
      保证最多每2次向CC请求一次内存.下面为,默认的分类和对应的移动数量.
      #+BEGIN_EXAMPLE
        class           num_to_move
      #+END_EXAMPLE
      以上只是默认值,这个值是会随着内存申请次数的增加而调整, google给这
      个算法取名为慢启动(slow-start)算法. 我们来看下.首先, list有个最大值,
      我们能移动的大小为list最大长度和默认中的最小值. 为了保证,在大量申
      请时的效率, 在max length < 默认值时,我们慢慢增长max length, 防止
      浪费空间,又能有效地逐渐提高效率. 在max length > 默认值时, 要么时
      大量请求,要么是由于请求的内存很大,导致默认值小,所以,这个时候,可以
      每次增加默认值大小.但最大移动数依然时默认的移动数.

#+BEGIN_SRC cpp
// Remove some objects of class "cl" from central cache and add to thread heap.
// On success, return the first object for immediate use; otherwise return NULL.
void* ThreadCache::FetchFromCentralCache(size_t cl, size_t byte_size) {
  FreeList* list = &list_[cl];
  ASSERT(list->empty());
  // batch_size 为默认的移动数量
  const int batch_size = Static::sizemap()->num_objects_to_move(cl);

  // 考虑到list的大小,我们取list最大长度和batch_size中的最小值.
  const int num_to_move = min<int>(list->max_length(), batch_size);
  void *start, *end;
  // 从CC获取内存, 只是简单的链表删除操作
  int fetch_count = Static::central_cache()[cl].RemoveRange(
      &start, &end, num_to_move);

  ASSERT((start == NULL) == (fetch_count == 0));
  if (--fetch_count >= 0) {
    // size_为获取到的内存大小
    size_ += byte_size * fetch_count;
    // 添加到单向链表中.链表插入操作.
    list->PushRange(fetch_count, SLL_Next(start), end);
  }

  // 如果list的最大长度 < 默认移动长度, 则list最大长度+1, 慢慢靠近默认移动长度.
  if (list->max_length() < batch_size) {
    list->set_max_length(list->max_length() + 1);
  } else {
    // 否则,我们直接增长batch_size 长度, 当然不允许无限增长.
    int new_length = min<int>(list->max_length() + batch_size,
                              kMaxDynamicFreeListLength);
    // 必须保证max_length 时batch_size的整数倍,这样才能做到在N次batch_size的移动正好释放完list, 而不需要分割.
    new_length -= new_length % batch_size;
    ASSERT(new_length % batch_size == 0);
    list->set_max_length(new_length);
  }
  return start;
}
#+END_SRC

      这里实际从CC获取空闲空间的函数是RemoveRange函数.首先尝试直接从
      slots中获取,如果slots不够,则再从spans获取.
#+BEGIN_SRC cpp
int CentralFreeList::RemoveRange(void **start, void **end, int N) {
  ASSERT(N > 0);
  lock_.Lock();
  if (N == Static::sizemap()->num_objects_to_move(size_class_) &&
      used_slots_ > 0) {
    int slot = --used_slots_;
    ASSERT(slot >= 0);
    TCEntry *entry = &tc_slots_[slot];
    *start = entry->head;
    *end = entry->tail;
    lock_.Unlock();
    return N;
  }

  int result = 0;
  void* head = NULL;
  void* tail = NULL;
  // TODO: Prefetch multiple TCEntries?
  tail = FetchFromSpansSafe();
  if (tail != NULL) {
    SLL_SetNext(tail, NULL);
    head = tail;
    result = 1;
    while (result < N) {
      void *t = FetchFromSpans();
      if (!t) break;
      SLL_Push(&head, t);
      result++;
    }
  }
  lock_.Unlock();
  *start = head;
  *end = tail;
  return result;
}
#+END_SRC

#+BEGIN_SRC cpp
int SizeMap::NumMoveSize(size_t size) {
  if (size == 0) return 0;

  int num = static_cast<int>(64.0 * 1024.0 / size);
  if (num < 2) num = 2;

  if (num > FLAGS_tcmalloc_transfer_num_objects)
    num = FLAGS_tcmalloc_transfer_num_objects;

  return num;
}
#+END_SRC

***** TC向CC释放内存
      TC释放内存的触发条件是, 进程向TC释放内存并且(TC的size >
      max_size 或者 某个list的length > max_length). 在以上两种情况下,
      分别触发ListTooLong 函数释放list和Scavenge 释放整个TC空间.
      ListTooLong 释放内存的规则时,如果小于batch_size, 则清空链表,否则
      释放batch_size.一般会触发清空链表的话,也就意味着,这个线程基本不
      申请内存, 所以直接释放所有基本不影响效率.
      Scavenge 是通过编译TC中的所有类别链表,并释放内存实现内存回收.这
      里有个标准, lowwatermark. 在TC中lowwatermark是每个链表曾经最短的
      长度. 这个值不会增加,增加的情况只有是Scavenge被调用时,被设置为当
      前的长度, 而在list长度小于lowwatermark时,就会被持续递减.对于
      lowwatermark大于0的链表,将lowwatermark/2 的大小还给CC,并将该链表
      的最大值,设置低于batch_size,从而使其使用慢启动算法增加内存,减少
      内存浪费的情况.

#+BEGIN_SRC cpp
void ThreadCache::ListTooLong(FreeList* list, size_t cl) {
  const int batch_size = Static::sizemap()->num_objects_to_move(cl);
  // 如果list长度小于 batch_size, 释放所有, 否则, 释放batch_size个块.
  ReleaseToCentralCache(list, cl, batch_size);

  if (list->max_length() < batch_size) {
    // Slow start the max_length so we don't overreserve.
    list->set_max_length(list->max_length() + 1);
  } else if (list->max_length() > batch_size) {
    // If we consistently go over max_length, shrink max_length.  If we don't
    // shrink it, some amount of memory will always stay in this freelist.
    list->set_length_overages(list->length_overages() + 1);
    if (list->length_overages() > kMaxOverages) {
      ASSERT(list->max_length() > batch_size);
      list->set_max_length(list->max_length() - batch_size);
      list->set_length_overages(0);
    }
  }
}
#+END_SRC

      ReleaseToCentralCache 中执行了,将链表返回给CC的动作,里面涉及到了
      slots结构,我们来看下.
#+BEGIN_SRC cpp
// Remove some objects of class "cl" from thread heap and add to central cache
void ThreadCache::ReleaseToCentralCache(FreeList* src, size_t cl, int N) {
  ASSERT(src == &list_[cl]);
  if (N > src->length()) N = src->length();
  size_t delta_bytes = N * Static::sizemap()->ByteSizeForClass(cl);

  // We return prepackaged chains of the correct size to the central cache.
  // TODO: Use the same format internally in the thread caches?
  int batch_size = Static::sizemap()->num_objects_to_move(cl);
  while (N > batch_size) {
    void *tail, *head;
    src->PopRange(batch_size, &head, &tail);
    Static::central_cache()[cl].InsertRange(head, tail, batch_size);
    N -= batch_size;
  }
  void *tail, *head;
  src->PopRange(N, &head, &tail);
  Static::central_cache()[cl].InsertRange(head, tail, N);
  size_ -= delta_bytes;
}
#+END_SRC

      这个函数实际上是从TC释放到CC时调用.
#+BEGIN_SRC cpp
void CentralFreeList::InsertRange(void *start, void *end, int N) {
  SpinLockHolder h(&lock_);
  if (N == Static::sizemap()->num_objects_to_move(size_class_) &&
    MakeCacheSpace()) {
    // slots 是存在CC 的链表中的结构.
    // 每个CC的链表节点是slots.
    // 每个slots中的数据正好是TC中移动数据的大小.
    int slot = used_slots_++;
    ASSERT(slot >=0);
    ASSERT(slot < max_cache_size_);
    TCEntry *entry = &tc_slots_[slot];
    entry->head = start;
    entry->tail = end;
    return;
  }
  ReleaseListToSpans(start);
}
#+END_SRC

#+BEGIN_SRC cpp
void ThreadCache::Scavenge() {
  // If the low-water mark for the free list is L, it means we would
  // not have had to allocate anything from the central cache even if
  // we had reduced the free list size by L.  We aim to get closer to
  // that situation by dropping L/2 nodes from the free list.  This
  // may not release much memory, but if so we will call scavenge again
  // pretty soon and the low-water marks will be high on that call.
  //int64 start = CycleClock::Now();
  for (int cl = 0; cl < kNumClasses; cl++) {
    FreeList* list = &list_[cl];
    const int lowmark = list->lowwatermark();
    // 首先清理 lowmark > 0 的.就算某些lowmark值不对, 在该轮结束后,会通过clear_lowwatermark()重置,下一次将会成功释放大量内存.
    if (lowmark > 0) {
      const int drop = (lowmark > 1) ? lowmark/2 : 1;
      ReleaseToCentralCache(list, cl, drop);

      // Shrink the max length if it isn't used.  Only shrink down to
      // batch_size -- if the thread was active enough to get the max_length
      // above batch_size, it will likely be that active again.  If
      // max_length shinks below batch_size, the thread will have to
      // go through the slow-start behavior again.  The slow-start is useful
      // mainly for threads that stay relatively idle for their entire
      // lifetime.
      // 由于该TC内存快满了,所以,我们减少batch_size, 减慢慢启动算法,保证空间不会浪费太多.
      const int batch_size = Static::sizemap()->num_objects_to_move(cl);
      if (list->max_length() > batch_size) {
        list->set_max_length(
            max<int>(list->max_length() - batch_size, batch_size)); // 减少后和batch_size中的最大值.
      }
    }
    list->clear_lowwatermark();  //清理低水平标志位.其实就是设置为当前长度...
  }
  // 无耻地偷取其他线程的容量.
  IncreaseCacheLimit();
}
#+END_SRC

      以上是内存释放的情况,还有个保证自己线程容量充裕的无耻做法是,偷取其他线
      程的容量.偷取临近10个TC的 1 << 16容量. 当然,如果其容量小于最小值,就
      放过了．也就是说,对于很少启动慢启动的线程,其线程容量将会由于被偷
      取而持续减少, 有效控制了这种线程内存的浪费. 通过这种机制,有效地保
      证进程间空间不会浪费太多. 需求大的线程可以获得更多的容量,而需求
      小的线程获取少的容量.
      如果存在无人认领的内存,咱们就偷了!!所谓无人认领的内存,是指线程被
      释放后, 其释放的内存.

#+BEGIN_SRC cpp
void ThreadCache::IncreaseCacheLimitLocked() {
  if (unclaimed_cache_space_ > 0) {
    // Possibly make unclaimed_cache_space_ negative.
    unclaimed_cache_space_ -= kStealAmount;
    max_size_ += kStealAmount;
    return;
  }
  // Don't hold pageheap_lock too long.  Try to steal from 10 other
  // threads before giving up.  The i < 10 condition also prevents an
  // infinite loop in case none of the existing thread heaps are
  // suitable places to steal from.
  for (int i = 0; i < 10;
       ++i, next_memory_steal_ = next_memory_steal_->next_) {
    // Reached the end of the linked list.  Start at the beginning.
    if (next_memory_steal_ == NULL) {
      ASSERT(thread_heaps_ != NULL);
      // next_memory_steal_ 在初始化时默认为TC的Heap的链表头.
      // 所以,这个循环会不停轮流偷取链表里的所有线程,包括自己.
      next_memory_steal_ = thread_heaps_;
    }
    if (next_memory_steal_ == this ||
        next_memory_steal_->max_size_ <= kMinThreadCacheSize) {
      continue;
    }
    next_memory_steal_->max_size_ -= kStealAmount;
    max_size_ += kStealAmount;

    next_memory_steal_ = next_memory_steal_->next_;
    return;
  }
}
#+END_SRC


** 代码review

** 总结
   + 对图表的几个说明:
     + 图表是在线程数为4的基础上做的测试. 并且是在连续分配一定次数的内
       存后再连续释放,数据只能从一定程度上反映了tcmalloc与dlmalloc的性
       能差异.
     + 本次测试是计算出4个线程的内存请求和释放的平均时间, 和标准偏差.由
       于图表维度不够,只使用了平均时间作为实际的性能比较.
     + 测试时的两个变量分别为, 单次申请内存大小,和申请次数,性能指标为
       执行所有内存申请释放的线程平均时间.
     + 该数据不包含内存分配器初始化的时间(即,第一次内存分配时间).实际
       上,内存分配器初始化,tcmalloc花费的时间是dlmalloc多.但只
       是针对第一次,所以,不记录到图标数据中.
     + 以下所有提到的内存申请数,如未说明,都是指单次内存申请的大小.

   + 分析:
     + tcmalloc 内存分配概要:
       + tcmalloc 中存在分级请求内存的机制. 分为3级,分别为
         TC(ThreadCache), CC(Central Cache) 和 PH(PageHeap)
       + TC 向CC 申请内存, CC 向PH申请内存. 而他们之间的内存是批量移动,一
         般为申请内存对齐后的N倍进行移动.
       + TC 存在线程局部空间中. 向TC 申请内存不需要加解锁,向CC和PH 申
         请内存需要加解锁.
     + dlmalloc 内存分配概要:
       + dlmalloc每次内存申请都会执行加解锁操作.
       + 256byte以下的内存,从小内存分配. 256byte以上的从大内存分配.在
         空闲内存不够并且申请内存大于256K的,直接由mmap分配.

     + 首先,从图表可以得出一个结论,在单次内存30K以内的内存分配和释放,
       效率上,tcmalloc比dlmalloc高,并且在1K以内,申请次数大于26次的情况
       下,甚至可以达到10倍性能.原因是,在tcmalloc中,所有小于256k的内存
       都会优先从TC(避免加解锁操作)分配, 在TC不够的情况下,向CC申请 2 -
       32 倍的内存数量,并存放到TC中,相当于, N(N>2)次内存请求才执行1次
       加解锁. 而dlmalloc每次内存请求都会加解锁.所以,tcmalloc在小内存
       分配上,性能高于dlmalloc.
     + 而在30K - 256K, 在某些区域内,tcmalloc的性能反而不如dlmalloc. 可
       能原因如下: tcmalloc在每次往CC中拷贝数据时, 有个大小上限为64K,
       也有一个最小下限为2倍请求内存对齐后的大小. 所以,在这个
       区间内,相当于每2次内存请求都会加解一次锁. 而CC也有
       存在内存不足的情况,也会出现加解锁,进一步向PH申请空间. 所以,就相
       当于每次内存申请都会加解锁.至于,在申请次数达到一定值之
       后,tcmalloc的性能又高于dlmalloc的原因是:CC与PH之间的内存移动的
       值是动态修正的,也就是说,在申请次数达到一定值之后,CC向PH申请的内
       存数变大,而请求次数减少,导致tcmalloc的性能再次提升.
     + > 256K 的情况下,tcmalloc的性能也略好于dlmalloc. 原因未知.分析如
       下. 在这种情况下,对于dlmalloc而言,如果没有足够
       空闲内存(本次测试中不可能有足够空闲内存), dlmalloc会直接调用
       mmap进行内存分配, 相当与一次加解锁,一次系统调用的时间.而
       tcmalloc依然向PH申请内存,当然PH也会直接从系统分配.

   + 结论: (以下结论,只有1从图表中得出)
     + 大量小内存请求的情况下,tcmalloc性能高于dlmalloc, 节省了加解锁的
       时间.
     + 如果只存在少量的内存请求,即使是小内存,从总的申请内存时间
       上,dlmalloc会优于tcmalloc,原因是,在第一次内存申请时,tcmalloc初
       始化的时间是dlmalloc的近10倍.
     + 从代码中分析,tcmalloc的内存利用率小于dlmalloc,虽然,tcmalloc使用
       了各种算法来提高内存利用率,但依然无法避免线程局部空间中的内存浪
       费.

   + 该测试的局限性:
     + 由于该测试是连续内存申请之后,连续释放,所以无法测试申请已释放内
       存的效率.但从代码上和tcmalloc/dlmalloc加解锁的机制上看,tcmalloc
       依然会优于dlmalloc.
     + 无法测试对于生命周期超长的进程,内存的碎片率.


** 草稿

+ 主要函数
#+BEGIN_SRC cpp
extern "C" PERFTOOLS_DLL_DECL void* tc_malloc(size_t size) __THROW
extern "C" PERFTOOLS_DLL_DECL void tc_free(void* ptr) __THROW
extern "C" PERFTOOLS_DLL_DECL void* tc_calloc(size_t n,
                                              size_t elem_size) __THROW
extern "C" PERFTOOLS_DLL_DECL void tc_cfree(void* ptr) __THROW
extern "C" PERFTOOLS_DLL_DECL void* tc_realloc(void* old_ptr,
                                               size_t new_size) __THROW
extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size)
extern "C" PERFTOOLS_DLL_DECL void tc_delete(void* p) __THROW
#+END_SRC

   真正分配内存的函数是do_malloc函数.

*** tc_malloc

#+BEGIN_SRC cpp
// line: 1577 file: /root/git/gperftools/src/tcmalloc.cc
extern "C" PERFTOOLS_DLL_DECL void* tc_malloc(size_t size) __THROW {
  void* result = do_malloc_or_cpp_alloc(size);
  MallocHook::InvokeNewHook(result, size);
  return result;
}
// line: 1581
#+END_SRC

#+BEGIN_SRC cpp
// line: 1038 file: /root/git/gperftools/src/tcmalloc.cc
inline void* do_malloc_or_cpp_alloc(size_t size) {
  // tc_new_mode 是指是否使用cpp的new来替换malloc实现.
  // 默认情况下为使用malloc, 所以代码进入do_malloc(size);
  return tc_new_mode ? cpp_alloc(size, true) : do_malloc(size);
}
// line: 1041
#+END_SRC

#+BEGIN_SRC cpp
// line: 1118 file: /root/git/gperftools/src/tcmalloc.cc
inline void* do_malloc(size_t size) {
  void* ret = do_malloc_no_errno(size);
  // UNLIKELY 是gcc的优化扩展,表示其测试成立条件极低.
  //
  if (UNLIKELY(ret == NULL)) errno = ENOMEM;
  return ret;
}
// line: 1123
#+END_SRC
    [[UNLIKELY][UNLIKELY]]

#+BEGIN_SRC cpp
// line: 1107 file: /root/git/gperftools/src/tcmalloc.cc
inline void* do_malloc_no_errno(size_t size) {
  if (ThreadCache::have_tls &&
      LIKELY(size < ThreadCache::MinSizeForSlowPath())) {
    // 这里的逻辑实际上与 size <= kMaxSize类似.
    // 区别是,下面的逻辑会进行ThreadCache的初始化.
    // 而这里是直接获取ThreadCache中的Heap.
    return do_malloc_small(ThreadCache::GetCacheWhichMustBePresent(), size);
   // kMaxSize = 256 * 1024
  } else if (size <= kMaxSize) {
    // ThreadCache::GetCache 中会进行TC的初始化.
    return do_malloc_small(ThreadCache::GetCache(), size);
  } else {
    return do_malloc_pages(ThreadCache::GetCache(), size);
  }
}
// line: 1117
#+END_SRC
    [[MinSizeForSlowPath]]
    [[tcmalloc_tc_init]]

    #<<MinSizeForSlowPath>>
#+BEGIN_SRC cpp
// line:  436 file: /root/git/gperftools/src/thread_cache.h
inline size_t ThreadCache::MinSizeForSlowPath() {
#ifdef HAVE_TLS
  // 这里min_size_for_slow_path = kMaxSize + 1;
  // 具体设置这个值,在后面初始化时会提到.
  return threadlocal_data_.min_size_for_slow_path;
#else
  return 0;
#endif
}
// line:  443
#+END_SRC

    #<<UNLIKELY>>
#+BEGIN_SRC cpp
// line:   49 file: /root/git/gperftools/src/common.h
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
// line:   49
#+END_SRC

    #<<tcmalloc_tc_init>>
#+BEGIN_SRC cpp
// line:  417 file: /root/git/gperftools/src/thread_cache.h
inline ThreadCache* ThreadCache::GetCache() {
  ThreadCache* ptr = NULL;
  if (!tsd_inited_) {
    // init Module, global data
    InitModule();
  } else {
    ptr = GetThreadHeap();
  }
  //  init ThreadCache
  if (ptr == NULL) ptr = CreateCacheIfNecessary();
  return ptr;
}
// line:  427
#+END_SRC
    [[InitModule]]
    [[CreateCacheIfNecessary]]

    #<<InitModule>>
#+BEGIN_SRC cpp
// line:  314 file: /root/git/gperftools/src/thread_cache.cc
void ThreadCache::InitModule() {
  SpinLockHolder h(Static::pageheap_lock());
  if (!phinited) {
    // 从环境变量 TCMALLOC_MAX_TOTAL_THREAD_CACHE_BYTES 获取ThreadCache的最大值
    const char *tcb = TCMallocGetenvSafe("TCMALLOC_MAX_TOTAL_THREAD_CACHE_BYTES");
    if (tcb) {
      set_overall_thread_cache_size(strtoll(tcb, NULL, 10));
    }
    // 进程空间变量和alloctor初始化.
    Static::InitStaticVars();
    threadcache_allocator.Init();
    phinited = 1;
  }
}
// line:  325
#+END_SRC
    [[InitStaticVars]]
    [[allocator_init]]

    #<<InitStaticVars>>
#+BEGIN_SRC cpp
// line:   81 file: /root/git/gperftools/src/static_vars.cc
void Static::InitStaticVars() {
  // sizemap 初始化
  // 类似dlmalloc的分箱机制.
  // 按固定大小进行分类,在每个分类中存放对应大小的双向链表.
  sizemap_.Init();
  // 初始化span分配器
  span_allocator_.Init();
  span_allocator_.New(); // Reduce cache conflicts
  span_allocator_.New(); // Reduce cache conflicts
  stacktrace_allocator_.Init();
  bucket_allocator_.Init();
  // Do a bit of sanitizing: make sure central_cache is aligned properly
  CHECK_CONDITION((sizeof(central_cache_[0]) % 64) == 0);
  // 初始化central_cache_ 分类列表.
  for (int i = 0; i < kNumClasses; ++i) {
    central_cache_[i].Init(i);
  }

  // It's important to have PageHeap allocated, not in static storage,
  // so that HeapLeakChecker does not consider all the byte patterns stored
  // in is caches as pointers that are sources of heap object liveness,
  // which leads to it missing some memory leaks.
  // 初始化 PageHeap
  pageheap_ = new (MetaDataAlloc(sizeof(PageHeap))) PageHeap;
  // double linked list init
  DLL_Init(&sampled_objects_);
  Sampler::InitStatics();
}
// line:  102
#+END_SRC
    [[sizemap_init]]

    #<<sizemap_init>>
#+BEGIN_SRC cpp
// line:  122 file: /root/git/gperftools/src/common.cc
void SizeMap::Init() {
  // 初始化TC中对应TransferNumObjects.
  // TransferNumObjects 是
  InitTCMallocTransferNumObjects();

  // Do some sanity checking on add_amount[]/shift_amount[]/class_array[]
  // class 分类边界检查.
  // size 0 应该对应分类0
  // size Max 应该对应分类Max
  if (ClassIndex(0) != 0) {
    Log(kCrash, __FILE__, __LINE__,
        "Invalid class index for size 0", ClassIndex(0));
  }
  if (ClassIndex(kMaxSize) >= sizeof(class_array_)) {
    Log(kCrash, __FILE__, __LINE__,
        "Invalid class index for kMaxSize", ClassIndex(kMaxSize));
  }

  // Compute the size classes we want to use
  // 计算size classe 分类大小, 和对应的每个分类对应的
  // 计算结果如下:
  // class 1 :
  int sc = 1;   // Next size class to assign
  int alignment = kAlignment;
  CHECK_CONDITION(kAlignment <= kMinAlign);
  for (size_t size = kAlignment; size <= kMaxSize; size += alignment) {
    alignment = AlignmentForSize(size);
    CHECK_CONDITION((size % alignment) == 0);

    int blocks_to_move = NumMoveSize(size) / 4;
    size_t psize = 0;
    do {
      psize += kPageSize;
      // Allocate enough pages so leftover is less than 1/8 of total.
      // This bounds wasted space to at most 12.5%.
      while ((psize % size) > (psize >> 3)) {
        psize += kPageSize;
      }
      // Continue to add pages until there are at least as many objects in
      // the span as are needed when moving objects from the central
      // freelists and spans to the thread caches.
    } while ((psize / size) < (blocks_to_move));
    const size_t my_pages = psize >> kPageShift;

    if (sc > 1 && my_pages == class_to_pages_[sc-1]) {
      // See if we can merge this into the previous class without
      // increasing the fragmentation of the previous class.
      const size_t my_objects = (my_pages << kPageShift) / size;
      const size_t prev_objects = (class_to_pages_[sc-1] << kPageShift)
                                  / class_to_size_[sc-1];
      if (my_objects == prev_objects) {
        // Adjust last class to include this size
        class_to_size_[sc-1] = size;
        continue;
      }
    }

    // Add new class
    class_to_pages_[sc] = my_pages;
    class_to_size_[sc] = size;
    sc++;
  }
  if (sc != kNumClasses) {
    Log(kCrash, __FILE__, __LINE__,
        "wrong number of size classes: (found vs. expected )", sc, kNumClasses);
  }

  // Initialize the mapping arrays
  int next_size = 0;
  for (int c = 1; c < kNumClasses; c++) {
    const int max_size_in_class = class_to_size_[c];
    for (int s = next_size; s <= max_size_in_class; s += kAlignment) {
      class_array_[ClassIndex(s)] = c;
    }
    next_size = max_size_in_class + kAlignment;
  }

  // Double-check sizes just to be safe
  for (size_t size = 0; size <= kMaxSize;) {
    const int sc = SizeClass(size);
    if (sc <= 0 || sc >= kNumClasses) {
      Log(kCrash, __FILE__, __LINE__,
          "Bad size class (class, size)", sc, size);
    }
    if (sc > 1 && size <= class_to_size_[sc-1]) {
      Log(kCrash, __FILE__, __LINE__,
          "Allocating unnecessarily large class (class, size)", sc, size);
    }
    const size_t s = class_to_size_[sc];
    if (size > s || s == 0) {
      Log(kCrash, __FILE__, __LINE__,
          "Bad (class, size, requested)", sc, s, size);
    }
    if (size <= kMaxSmallSize) {
      size += 8;
    } else {
      size += 128;
    }
  }

  // Initialize the num_objects_to_move array.
  for (size_t cl = 1; cl  < kNumClasses; ++cl) {
    num_objects_to_move_[cl] = NumMoveSize(ByteSizeForClass(cl));
  }
}
// line:  218
#+END_SRC
    [[AlignmentForSize]]

    #<<AlignmentForSize>>
#+BEGIN_SRC cpp
// kPageShift = 13
// kNumClasses = 88
// kMinAlign = 16
// kAlignment  = 8
// kMaxSize    = 256 * 1024
// kPageSize   = 1 << kPageShift

// 计算结果如下:
// size         alignment
// >kMaxSize    kPageSize;
// >=128
// >= 16        16
// >= 8         8
int AlignmentForSize(size_t size) {
  int alignment = kAlignment;
  if (size > kMaxSize) {
    // Cap alignment at kPageSize for large sizes.
    alignment = kPageSize;
  } else if (size >= 128) {
    // Space wasted due to alignment is at most 1/8, i.e., 12.5%.
    alignment = (1 << LgFloor(size)) / 8;
  } else if (size >= kMinAlign) {
    // We need an alignment of at least 16 bytes to satisfy
    // requirements for some SSE types.
    alignment = kMinAlign;
  }
  // Maximum alignment allowed is page size alignment.
  if (alignment > kPageSize) {
    alignment = kPageSize;
  }
  CHECK_CONDITION(size < kMinAlign || alignment >= kMinAlign);
  CHECK_CONDITION((alignment & (alignment - 1)) == 0);
  return alignment;
}
#+END_SRC

    #<<allocator_init>>

    #<<CreateCacheIfNecessary>>
#+BEGIN_SRC cpp
// line:  345 file: /root/git/gperftools/src/thread_cache.cc
ThreadCache* ThreadCache::CreateCacheIfNecessary() {
  // Initialize per-thread data if necessary
  ThreadCache* heap = NULL;
  {
    SpinLockHolder h(Static::pageheap_lock());
    // 在某些老旧的glibc或者类unix系统中,如果在tcmalloc中过早调用pthread_self(),
    // 则会有可能引起崩溃.
#ifdef PTHREADS_CRASHES_IF_RUN_TOO_EARLY
    pthread_t me;
    if (!tsd_inited_) {
      memset(&me, 0, sizeof(me));
    } else {
      me = pthread_self();
    }
#else
    const pthread_t me = pthread_self();
#endif

    // 可能在之前, ThreadCache链表.
    // 初始化了. 我们先尝试搜索匹配该tid的ThreadCache结构.
    for (ThreadCache* h = thread_heaps_; h != NULL; h = h->next_) {
      if (h->tid_ == me) {
        heap = h;
        break;
      }
    }

    if (heap == NULL) heap = NewHeap(me);
  }

  // We call pthread_setspecific() outside the lock because it may
  // call malloc() recursively.  We check for the recursive call using
  // the "in_setspecific_" flag so that we can avoid calling
  // pthread_setspecific() if we are already inside pthread_setspecific().
  if (!heap->in_setspecific_ && tsd_inited_) {
    heap->in_setspecific_ = true;
    perftools_pthread_setspecific(heap_key_, heap);
#ifdef HAVE_TLS
    // 将ThreadCache保存在线程本地空间中.
    // 同时设置慢查找(大内存)的最小大小
    threadlocal_data_.heap = heap;
    SetMinSizeForSlowPath(kMaxSize + 1);
#endif
    heap->in_setspecific_ = false;
  }
  return heap;
}
// line:  396
#+END_SRC
    [[NewHeap]]

    #<<NewHeap>>
#+BEGIN_SRC cpp
// line:  398 file: /root/git/gperftools/src/thread_cache.cc
ThreadCache* ThreadCache::NewHeap(pthread_t tid) {
  // Create the heap and add it to the linked list
  // 创建heap结点并添加到双向链表中,非环形链表
  // threadcache_allocator 即为 Central Heap ?? 应该不是.
  ThreadCache *heap = threadcache_allocator.New();
  heap->Init(tid);
  heap->next_ = thread_heaps_;
  heap->prev_ = NULL;
  if (thread_heaps_ != NULL) {
    thread_heaps_->prev_ = heap;
  } else {
    ASSERT(next_memory_steal_ == NULL);
    // 这个变量是用于线程间内存偷取用.
    // 也就是线程A可以偷取线程B的空闲内存.
    // 此处是由于链表为空,所以将偷取对象设置为自己.
    next_memory_steal_ = heap;
  }
  thread_heaps_ = heap;
  thread_heap_count_++;
  return heap;
}
// line:  414
#+END_SRC
    [[thread_allocator_New]]

    #<<thread_allocator_New>>
#+BEGIN_SRC cpp
// line:   62 file: /root/git/gperftools/src/page_heap_allocator.h
  T* New() {
    // 一个内存管理模版.
    // Consult free list
    void* result;
    if (free_list_ != NULL) {
      result = free_list_;
      free_list_ = *(reinterpret_cast<void**>(result));
    } else {
      if (free_avail_ < sizeof(T)) {
        // Need more room. We assume that MetaDataAlloc returns
        // suitably aligned memory.
        free_area_ = reinterpret_cast<char*>(MetaDataAlloc(kAllocIncrement));
        if (free_area_ == NULL) {
          Log(kCrash, __FILE__, __LINE__,
              "FATAL ERROR: Out of memory trying to allocate internal "
              "tcmalloc data (bytes, object-size)",
              kAllocIncrement, sizeof(T));
        }
        free_avail_ = kAllocIncrement;
      }
      result = free_area_;
      free_area_ += sizeof(T);
      free_avail_ -= sizeof(T);
    }
    inuse_++;
    return reinterpret_cast<T*>(result);
  }
// line:   87
#+END_SRC
