* tcmalloc2.1 浅析

** 简介
   tcmalloc(thread cached malloc) 是由google为并发程序而开发的内存分配管理器.tcmalloc致力于
   减少多线程内存请求时对锁的竞争, 在对小内存的申请时, 可以在无需锁的
   情况下高效获取内存;而在获取大内存时,使用高校的spinlocks.正因为
   tcmalloc是在线程局部空间(TLS)预先存储部分空闲内存用于分配, 在程序刚
   启动时,其所占用的内存会比dlmalloc或其他的内存管理器更大,但其增长速
   幅度比其他管理器小,所以,在后期,实际占用内存空间会相接近.

** 原理简析

*** overview

    [[https://raw.githubusercontent.com/pengzhangdev/documents/master/tcmalloc/overview.gif]]

    tcmalloc为每一个线程分配一个线程本地缓存(Thread Cache)．所有小对象
    (<256K)都会优先从Thread Cache分配．而当Thread Cache没有足够空闲内
    存时，就会从Central Heap申请内存. 而当Thread Cache内存富裕时,会将
    内存返回给Central Heap. Central Heap 是以进程为单位存在,Thread
    Cache是以线程为单位存在.
    对于大内存(>256K), 直接从Central Heap 按页对齐(4K)申请.
    通常情况下, 一连串的页面(4k)可以多个小内存序列,每个序列元素等大小.

*** 小对象内存分配
    [[https://raw.githubusercontent.com/pengzhangdev/documents/master/tcmalloc/threadheap.gif]]
    上图为小内存管理时的sizemap分类的示意图.针对小内存,

** 代码review

** 总结


** 草稿

+ 主要函数
#+BEGIN_SRC cpp
extern "C" PERFTOOLS_DLL_DECL void* tc_malloc(size_t size) __THROW
extern "C" PERFTOOLS_DLL_DECL void tc_free(void* ptr) __THROW
extern "C" PERFTOOLS_DLL_DECL void* tc_calloc(size_t n,
                                              size_t elem_size) __THROW
extern "C" PERFTOOLS_DLL_DECL void tc_cfree(void* ptr) __THROW
extern "C" PERFTOOLS_DLL_DECL void* tc_realloc(void* old_ptr,
                                               size_t new_size) __THROW
extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size)
extern "C" PERFTOOLS_DLL_DECL void tc_delete(void* p) __THROW
#+END_SRC

   真正分配内存的函数是do_malloc函数.

*** tc_malloc

#+BEGIN_SRC cpp
// line: 1577 file: /root/git/gperftools/src/tcmalloc.cc
extern "C" PERFTOOLS_DLL_DECL void* tc_malloc(size_t size) __THROW {
  void* result = do_malloc_or_cpp_alloc(size);
  MallocHook::InvokeNewHook(result, size);
  return result;
}
// line: 1581
#+END_SRC

#+BEGIN_SRC cpp
// line: 1038 file: /root/git/gperftools/src/tcmalloc.cc
inline void* do_malloc_or_cpp_alloc(size_t size) {
  // tc_new_mode 是指是否使用cpp的new来替换malloc实现.
  // 默认情况下为使用malloc, 所以代码进入do_malloc(size);
  return tc_new_mode ? cpp_alloc(size, true) : do_malloc(size);
}
// line: 1041
#+END_SRC

#+BEGIN_SRC cpp
// line: 1118 file: /root/git/gperftools/src/tcmalloc.cc
inline void* do_malloc(size_t size) {
  void* ret = do_malloc_no_errno(size);
  // UNLIKELY 是gcc的优化扩展,表示其测试成立条件极低.
  //
  if (UNLIKELY(ret == NULL)) errno = ENOMEM;
  return ret;
}
// line: 1123
#+END_SRC
[[UNLIKELY][UNLIKELY]]

#+BEGIN_SRC cpp
// line: 1107 file: /root/git/gperftools/src/tcmalloc.cc
inline void* do_malloc_no_errno(size_t size) {
  if (ThreadCache::have_tls &&
      LIKELY(size < ThreadCache::MinSizeForSlowPath())) {
    // 这里的逻辑实际上与 size <= kMaxSize类似.
    // 区别是,下面的逻辑会进行ThreadCache的初始化.
    // 而这里是直接获取ThreadCache中的Heap.
    return do_malloc_small(ThreadCache::GetCacheWhichMustBePresent(), size);
   // kMaxSize = 256 * 1024
  } else if (size <= kMaxSize) {
    // ThreadCache::GetCache 中会进行TC的初始化.
    return do_malloc_small(ThreadCache::GetCache(), size);
  } else {
    return do_malloc_pages(ThreadCache::GetCache(), size);
  }
}
// line: 1117
#+END_SRC
[[MinSizeForSlowPath]]
[[tcmalloc_tc_init]]

#<<MinSizeForSlowPath>>
#+BEGIN_SRC cpp
// line:  436 file: /root/git/gperftools/src/thread_cache.h
inline size_t ThreadCache::MinSizeForSlowPath() {
#ifdef HAVE_TLS
  // 这里min_size_for_slow_path = kMaxSize + 1;
  // 具体设置这个值,在后面初始化时会提到.
  return threadlocal_data_.min_size_for_slow_path;
#else
  return 0;
#endif
}
// line:  443
#+END_SRC

#<<UNLIKELY>>
#+BEGIN_SRC cpp
// line:   49 file: /root/git/gperftools/src/common.h
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
// line:   49
#+END_SRC

#<<tcmalloc_tc_init>>
#+BEGIN_SRC cpp
// line:  417 file: /root/git/gperftools/src/thread_cache.h
inline ThreadCache* ThreadCache::GetCache() {
  ThreadCache* ptr = NULL;
  if (!tsd_inited_) {
    // init Module, global data
    InitModule();
  } else {
    ptr = GetThreadHeap();
  }
  //  init ThreadCache
  if (ptr == NULL) ptr = CreateCacheIfNecessary();
  return ptr;
}
// line:  427
#+END_SRC
[[InitModule]]
[[CreateCacheIfNecessary]]

#<<InitModule>>
#+BEGIN_SRC cpp
// line:  314 file: /root/git/gperftools/src/thread_cache.cc
void ThreadCache::InitModule() {
  SpinLockHolder h(Static::pageheap_lock());
  if (!phinited) {
    // 从环境变量 TCMALLOC_MAX_TOTAL_THREAD_CACHE_BYTES 获取ThreadCache的最大值
    const char *tcb = TCMallocGetenvSafe("TCMALLOC_MAX_TOTAL_THREAD_CACHE_BYTES");
    if (tcb) {
      set_overall_thread_cache_size(strtoll(tcb, NULL, 10));
    }
    // 进程空间变量和alloctor初始化.
    Static::InitStaticVars();
    threadcache_allocator.Init();
    phinited = 1;
  }
}
// line:  325
#+END_SRC
[[InitStaticVars]]
[[allocator_init]]

#<<InitStaticVars>>
#+BEGIN_SRC cpp
// line:   81 file: /root/git/gperftools/src/static_vars.cc
void Static::InitStaticVars() {
  // sizemap 初始化
  // dlmalloc的分箱机制.
  // 按固定大小进行分类,在每个分类中存放对应大小的双向链表.
  sizemap_.Init();
  span_allocator_.Init();
  span_allocator_.New(); // Reduce cache conflicts
  span_allocator_.New(); // Reduce cache conflicts
  stacktrace_allocator_.Init();
  bucket_allocator_.Init();
  // Do a bit of sanitizing: make sure central_cache is aligned properly
  CHECK_CONDITION((sizeof(central_cache_[0]) % 64) == 0);
  for (int i = 0; i < kNumClasses; ++i) {
    central_cache_[i].Init(i);
  }

  // It's important to have PageHeap allocated, not in static storage,
  // so that HeapLeakChecker does not consider all the byte patterns stored
  // in is caches as pointers that are sources of heap object liveness,
  // which leads to it missing some memory leaks.
  pageheap_ = new (MetaDataAlloc(sizeof(PageHeap))) PageHeap;
  DLL_Init(&sampled_objects_);
  Sampler::InitStatics();
}
// line:  102
#+END_SRC
[[sizemap_init]]


#<<sizemap_init>>
#+BEGIN_SRC cpp
// line:  122 file: /root/git/gperftools/src/common.cc
void SizeMap::Init() {
  InitTCMallocTransferNumObjects();

  // Do some sanity checking on add_amount[]/shift_amount[]/class_array[]
  if (ClassIndex(0) != 0) {
    Log(kCrash, __FILE__, __LINE__,
        "Invalid class index for size 0", ClassIndex(0));
  }
  if (ClassIndex(kMaxSize) >= sizeof(class_array_)) {
    Log(kCrash, __FILE__, __LINE__,
        "Invalid class index for kMaxSize", ClassIndex(kMaxSize));
  }

  // Compute the size classes we want to use
  int sc = 1;   // Next size class to assign
  int alignment = kAlignment;
  CHECK_CONDITION(kAlignment <= kMinAlign);
  for (size_t size = kAlignment; size <= kMaxSize; size += alignment) {
    alignment = AlignmentForSize(size);
    CHECK_CONDITION((size % alignment) == 0);

    int blocks_to_move = NumMoveSize(size) / 4;
    size_t psize = 0;
    do {
      psize += kPageSize;
      // Allocate enough pages so leftover is less than 1/8 of total.
      // This bounds wasted space to at most 12.5%.
      while ((psize % size) > (psize >> 3)) {
        psize += kPageSize;
      }
      // Continue to add pages until there are at least as many objects in
      // the span as are needed when moving objects from the central
      // freelists and spans to the thread caches.
    } while ((psize / size) < (blocks_to_move));
    const size_t my_pages = psize >> kPageShift;

    if (sc > 1 && my_pages == class_to_pages_[sc-1]) {
      // See if we can merge this into the previous class without
      // increasing the fragmentation of the previous class.
      const size_t my_objects = (my_pages << kPageShift) / size;
      const size_t prev_objects = (class_to_pages_[sc-1] << kPageShift)
                                  / class_to_size_[sc-1];
      if (my_objects == prev_objects) {
        // Adjust last class to include this size
        class_to_size_[sc-1] = size;
        continue;
      }
    }

    // Add new class
    class_to_pages_[sc] = my_pages;
    class_to_size_[sc] = size;
    sc++;
  }
  if (sc != kNumClasses) {
    Log(kCrash, __FILE__, __LINE__,
        "wrong number of size classes: (found vs. expected )", sc, kNumClasses);
  }

  // Initialize the mapping arrays
  int next_size = 0;
  for (int c = 1; c < kNumClasses; c++) {
    const int max_size_in_class = class_to_size_[c];
    for (int s = next_size; s <= max_size_in_class; s += kAlignment) {
      class_array_[ClassIndex(s)] = c;
    }
    next_size = max_size_in_class + kAlignment;
  }

  // Double-check sizes just to be safe
  for (size_t size = 0; size <= kMaxSize;) {
    const int sc = SizeClass(size);
    if (sc <= 0 || sc >= kNumClasses) {
      Log(kCrash, __FILE__, __LINE__,
          "Bad size class (class, size)", sc, size);
    }
    if (sc > 1 && size <= class_to_size_[sc-1]) {
      Log(kCrash, __FILE__, __LINE__,
          "Allocating unnecessarily large class (class, size)", sc, size);
    }
    const size_t s = class_to_size_[sc];
    if (size > s || s == 0) {
      Log(kCrash, __FILE__, __LINE__,
          "Bad (class, size, requested)", sc, s, size);
    }
    if (size <= kMaxSmallSize) {
      size += 8;
    } else {
      size += 128;
    }
  }

  // Initialize the num_objects_to_move array.
  for (size_t cl = 1; cl  < kNumClasses; ++cl) {
    num_objects_to_move_[cl] = NumMoveSize(ByteSizeForClass(cl));
  }
}
// line:  218
#+END_SRC

#<<allocator_init>>

#<<CreateCacheIfNecessary>>
#+BEGIN_SRC cpp
// line:  345 file: /root/git/gperftools/src/thread_cache.cc
ThreadCache* ThreadCache::CreateCacheIfNecessary() {
  // Initialize per-thread data if necessary
  ThreadCache* heap = NULL;
  {
    SpinLockHolder h(Static::pageheap_lock());
    // 在某些老旧的glibc或者类unix系统中,如果在tcmalloc中过早调用pthread_self(),
    // 则会有可能引起崩溃.
#ifdef PTHREADS_CRASHES_IF_RUN_TOO_EARLY
    pthread_t me;
    if (!tsd_inited_) {
      memset(&me, 0, sizeof(me));
    } else {
      me = pthread_self();
    }
#else
    const pthread_t me = pthread_self();
#endif

    // 可能在之前, ThreadCache链表.
    // 初始化了. 我们先尝试搜索匹配该tid的ThreadCache结构.
    for (ThreadCache* h = thread_heaps_; h != NULL; h = h->next_) {
      if (h->tid_ == me) {
        heap = h;
        break;
      }
    }

    if (heap == NULL) heap = NewHeap(me);
  }

  // We call pthread_setspecific() outside the lock because it may
  // call malloc() recursively.  We check for the recursive call using
  // the "in_setspecific_" flag so that we can avoid calling
  // pthread_setspecific() if we are already inside pthread_setspecific().
  if (!heap->in_setspecific_ && tsd_inited_) {
    heap->in_setspecific_ = true;
    perftools_pthread_setspecific(heap_key_, heap);
#ifdef HAVE_TLS
    // 将ThreadCache保存在线程本地空间中.
    // 同时设置慢查找(大内存)的最小大小
    threadlocal_data_.heap = heap;
    SetMinSizeForSlowPath(kMaxSize + 1);
#endif
    heap->in_setspecific_ = false;
  }
  return heap;
}
// line:  396
#+END_SRC
[[NewHeap]]

#<<NewHeap>>
#+BEGIN_SRC cpp
// line:  398 file: /root/git/gperftools/src/thread_cache.cc
ThreadCache* ThreadCache::NewHeap(pthread_t tid) {
  // Create the heap and add it to the linked list
  // 创建heap结点并添加到双向链表中,非环形链表
  // threadcache_allocator 即为 Central Heap ?? 应该不是.
  ThreadCache *heap = threadcache_allocator.New();
  heap->Init(tid);
  heap->next_ = thread_heaps_;
  heap->prev_ = NULL;
  if (thread_heaps_ != NULL) {
    thread_heaps_->prev_ = heap;
  } else {
    ASSERT(next_memory_steal_ == NULL);
    // 这个变量是用于线程间内存偷取用.
    // 也就是线程A可以偷取线程B的空闲内存.
    // 此处是由于链表为空,所以将偷取对象设置为自己.
    next_memory_steal_ = heap;
  }
  thread_heaps_ = heap;
  thread_heap_count_++;
  return heap;
}
// line:  414
#+END_SRC
[[thread_allocator_New]]

#<<thread_allocator_New>>
#+BEGIN_SRC cpp
// line:   62 file: /root/git/gperftools/src/page_heap_allocator.h
  T* New() {
    // 一个内存管理模版.
    // Consult free list
    void* result;
    if (free_list_ != NULL) {
      result = free_list_;
      free_list_ = *(reinterpret_cast<void**>(result));
    } else {
      if (free_avail_ < sizeof(T)) {
        // Need more room. We assume that MetaDataAlloc returns
        // suitably aligned memory.
        free_area_ = reinterpret_cast<char*>(MetaDataAlloc(kAllocIncrement));
        if (free_area_ == NULL) {
          Log(kCrash, __FILE__, __LINE__,
              "FATAL ERROR: Out of memory trying to allocate internal "
              "tcmalloc data (bytes, object-size)",
              kAllocIncrement, sizeof(T));
        }
        free_avail_ = kAllocIncrement;
      }
      result = free_area_;
      free_area_ += sizeof(T);
      free_avail_ -= sizeof(T);
    }
    inuse_++;
    return reinterpret_cast<T*>(result);
  }
// line:   87
#+END_SRC
